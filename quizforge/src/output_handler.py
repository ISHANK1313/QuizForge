import os
import logging
from typing import List, Dict, Any
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import Paragraph
from reportlab.lib.units import inch

class Formatter:
    """
    Structure question bank.
    """
    def __init__(self):
        pass

    def group_by_difficulty(self, questions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Group questions by difficulty.

        Args:
            questions (List[Dict]): List of questions.

        Returns:
            Dict: Grouped questions.
        """
        grouped = {'easy': [], 'medium': [], 'hard': []}
        for q in questions:
            diff = q.get('difficulty', 'medium')
            if diff in grouped:
                grouped[diff].append(q)
            else:
                grouped['medium'].append(q)
        return grouped

    def format_question_text(self, question: Dict[str, Any], index: int) -> str:
        """
        Format question text with numbering.

        Args:
            question (Dict): Question dictionary.
            index (int): Question number.

        Returns:
            str: Formatted string.
        """
        return f"{index}. {question['question']}"

    def create_summary_stats(self, questions: List[Dict[str, Any]]) -> Dict[str, int]:
        """
        Create summary statistics.

        Args:
            questions (List[Dict]): List of questions.

        Returns:
            Dict: Statistics.
        """
        grouped = self.group_by_difficulty(questions)
        return {
            'total': len(questions),
            'easy': len(grouped['easy']),
            'medium': len(grouped['medium']),
            'hard': len(grouped['hard'])
        }


class PDFGenerator:
    """
    Create formatted PDF using ReportLab.
    """
    def __init__(self, output_path: str):
        """
        Initialize PDFGenerator.

        Args:
            output_path (str): Path to save PDF.
        """
        self.output_path = output_path
        self.width, self.height = letter
        self.styles = getSampleStyleSheet()
        self.style_normal = self.styles['Normal']
        self.style_heading = self.styles['Heading1']
        self.style_subheading = self.styles['Heading2']

    def _draw_text_wrapped(self, canvas_obj, text: str, x: float, y: float, max_width: float) -> float:
        """
        Helper to draw wrapped text. Returns the new y position.
        """
        p = Paragraph(text, self.style_normal)
        w, h = p.wrap(max_width, self.height)
        p.drawOn(canvas_obj, x, y - h)
        return y - h - 12 # Add some spacing

    def create_title_page(self, c, title: str, metadata: Dict[str, Any]):
        """
        Create title page.

        Args:
            c: ReportLab Canvas object.
            title (str): Title of the document.
            metadata (Dict): Metadata dictionary.
        """
        c.saveState()
        c.setFont("Helvetica-Bold", 24)
        c.drawCentredString(self.width / 2, self.height - 200, title)

        c.setFont("Helvetica", 14)
        y = self.height - 250
        for key, value in metadata.items():
            c.drawCentredString(self.width / 2, y, f"{key}: {value}")
            y -= 20

        c.setFont("Helvetica-Oblique", 10)
        c.drawCentredString(self.width / 2, 50, "Generated by QuizForge")
        c.restoreState()
        c.showPage()

    def add_questions_section(self, c, questions: List[Dict[str, Any]]):
        """
        Add questions organized by difficulty.

        Args:
            c: Canvas object.
            questions (List[Dict]): List of questions.
        """
        formatter = Formatter()
        grouped = formatter.group_by_difficulty(questions)

        y = self.height - 50
        margin = 50
        max_width = self.width - 2 * margin

        # Order: Easy -> Medium -> Hard
        order = ['easy', 'medium', 'hard']

        question_idx = 1

        for diff in order:
            qs = grouped.get(diff, [])
            if not qs:
                continue

            # Section Header
            if y < 100:
                c.showPage()
                y = self.height - 50

            c.setFont("Helvetica-Bold", 16)
            c.setFillColor(colors.darkblue)
            c.drawString(margin, y, f"{diff.capitalize()} Questions")
            c.setFillColor(colors.black)
            y -= 30

            for q in qs:
                if y < 80:
                    c.showPage()
                    y = self.height - 50

                text = formatter.format_question_text(q, question_idx)

                # Draw question text wrapped
                y = self._draw_text_wrapped(c, text, margin, y, max_width)

                # Add some space for writing answer
                y -= 20
                c.line(margin, y, self.width - margin, y) # Answer line
                y -= 20

                question_idx += 1

            y -= 20 # Extra space between sections

    def add_answer_section(self, c, questions: List[Dict[str, Any]]):
        """
        Add answer key section.

        Args:
            c: Canvas object.
            questions (List[Dict]): List of questions.
        """
        c.showPage()
        y = self.height - 50
        margin = 50
        max_width = self.width - 2 * margin

        c.setFont("Helvetica-Bold", 16)
        c.drawString(margin, y, "Answer Key")
        y -= 30

        formatter = Formatter()
        grouped = formatter.group_by_difficulty(questions)
        order = ['easy', 'medium', 'hard']

        idx = 1
        for diff in order:
            qs = grouped.get(diff, [])
            for q in qs:
                if y < 50:
                    c.showPage()
                    y = self.height - 50

                # Extract answer or hint
                answer_val = q.get('answer', 'Refer to context.')
                source_val = q.get('source', '')

                answer_text = f"{idx}. ({diff}) Answer: {answer_val}"

                # Draw Answer
                y = self._draw_text_wrapped(c, answer_text, margin, y, max_width)

                # Optionally draw context if it's a sentence (not just "Refer to text")
                if source_val and len(source_val) > 20 and "Refer to" not in source_val:
                     context_text = f"   Context: {source_val}"
                     y = self._draw_text_wrapped(c, context_text, margin + 20, y, max_width - 20)

                y -= 5 # Extra spacing
                idx += 1

    def generate(self, questions: List[Dict[str, Any]]) -> str:
        """
        Generate the PDF.

        Args:
            questions (List[Dict]): List of questions.

        Returns:
            str: Path to the generated file.
        """
        try:
            c = canvas.Canvas(self.output_path, pagesize=letter)
            c.setTitle("QuizForge Question Bank")

            # Title Page
            from datetime import datetime
            metadata = {
                "Total Questions": len(questions),
                "Date": datetime.now().strftime("%Y-%m-%d")
            }
            self.create_title_page(c, "QuizForge Question Bank", metadata)

            # Questions
            self.add_questions_section(c, questions)

            # Answers
            self.add_answer_section(c, questions)

            c.save()
            logging.info(f"PDF generated at {self.output_path}")
            return self.output_path
        except Exception as e:
            logging.error(f"Error generating PDF: {e}")
            raise
